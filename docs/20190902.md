# Mobx 源码分析 - computed

## 用法

下文会以此作为依据进行讲解

```js
class Foo{
    @computed get age() { return expr; } // 推荐用法
}
```

## 源码剖析

### 属性劫持

通过调用 `createPropDecorator` 方法给原型对象创建一个不可枚举的 `__mobxDecorators` 属性对象，`age` 会作为属性对象的 `key` 存在，此方法会返回一个描述符。

```js
{
    configurable: true,
    enumerable: enumerable,
    get() {
        initializeInstance(this)
        return this[prop]
    },
    set(value) {
        initializeInstance(this)
        this[prop] = value
    }
}
```

我们发现这里劫持了属性的 `get` 和 `set` 操作，每当执行 `get` 和 `set` 操作之前，都会先执行 `initializeInstance`。

`initializeInstance` 方法会执行 `propertyCreator` 方法，`propertyCreator` 对应 `createPropDecorator` 方法的第二个参数。

把 `get` 和 `set` 与 `decoratorArgs[0]` 当做 `defineComputedProperty` 第三个参数传递进去。

```js
const { get, set } = descriptor
const options = decoratorArgs[0] || {}
defineComputedProperty(instance, propertyName, { get, set, ...options })
```

### defineComputedProperty

```js
const adm = asObservableObject(target)
options.name = `${adm.name}.${propName}`
options.context = target
adm.values[propName] = new ComputedValue(options)
Object.defineProperty(target, propName, generateComputedPropConfig(propName))
```

`asObservableObject` 主要作用为在原型对象上新增 `$mobx` 属性，`age` 会作为属性的 `key` 存在，属性值为 `ObservableObjectAdministration` 实例。

修改 `adm.values[propName]` 为 `ComputedValue` 的实例，`generateComputedPropConfig` 再一次劫持 `get` 和 `set`，每当 `get` 或 `set` 实例( **这里的实例指 Foo 的实例** )的 `age` 属性，实际上是访问 `$mobx` 原型上的 `read` 和 `write`。

### 访问 age

前文说过，访问 `age` 实际上是访问 `$mobx` 原型上的 `read`，而 `read` 又返回当前实例( 在这里，实例指 `ObservableObjectAdministration` 实例 ) 的 `values.age` 值，也就是相当于访问 `ComputedValue` 实例的 `get` 方法。总结下，访问 `age` 相当于访问 `ComputedValue` 实例的 `get` 方法。


